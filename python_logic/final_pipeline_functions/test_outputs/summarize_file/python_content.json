{
    "generate_summaries.py": {
        "code": "import sys\nimport os\nimport json\n\nfrom openai import OpenAI\nclient = OpenAI(api_key=\"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\")\n\ndef summarize_functions(python_file_string):\n    response = client.chat.completions.create(\n    model=\"gpt-4o-2024-08-06\",\n    messages=[\n        {\n        \"role\": \"system\",\n        \"content\": [\n            {\n            \"text\": \"You are a python code summarizer. You will see python code. You should summarize all functions based on what they do with respect to the whole script.\",\n            \"type\": \"text\"\n            }\n        ]\n        },\n        {\n        \"role\": \"user\",\n        \"content\": [\n            {\n            \"type\": \"text\",\n            \"text\": \"import random\\n\\ndef generate_random_numbers(n, lower, upper):\\n    return [random.randint(lower, upper) for _ in range(n)]\\n\\ndef calculate_mean(numbers):\\n    return sum(numbers) / len(numbers)\\n\\ndef calculate_median(numbers):\\n    sorted_numbers = sorted(numbers)\\n    mid = len(sorted_numbers) // 2\\n    return (sorted_numbers[mid] if len(sorted_numbers) % 2 != 0 \\n            else (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2)\\n\\ndef calculate_variance(numbers, mean):\\n    return sum((x - mean) ** 2 for x in numbers) / len(numbers)\\n\\ndef calculate_standard_deviation(variance):\\n    return variance ** 0.5\\n\\ndef sort_numbers(numbers, descending=False):\\n    return sorted(numbers, reverse=descending)\\n\\ndef generate_statistics(numbers):\\n    mean = calculate_mean(numbers)\\n    median = calculate_median(numbers)\\n    variance = calculate_variance(numbers, mean)\\n    std_deviation = calculate_standard_deviation(variance)\\n    return {\\n        'mean': mean,\\n        'median': median,\\n        'variance': variance,\\n        'std_deviation': std_deviation\\n    }\\n\\ndef print_statistics(stats):\\n    for key, value in stats.items():\\n        print(f\\\"{key.capitalize()}: {value:.2f}\\\")\\n\\ndef main():\\n    n = 50\\n    lower_bound = 10\\n    upper_bound = 100\\n    random_numbers = generate_random_numbers(n, lower_bound, upper_bound)\\n    sorted_numbers = sort_numbers(random_numbers)\\n    stats = generate_statistics(sorted_numbers)\\n    print_statistics(stats)\\n\\nmain()\"\n            }\n        ]\n        },\n        {\n        \"role\": \"assistant\",\n        \"content\": [\n            {\n            \"type\": \"text\",\n            \"text\": \"{\\\"function_information\\\":[{\\\"function_name\\\":\\\"generate_random_numbers\\\",\\\"function_description\\\":\\\"Generates a list of 'n' random integers between 'lower' and 'upper' bounds.\\\"},{\\\"function_name\\\":\\\"calculate_mean\\\",\\\"function_description\\\":\\\"Calculates and returns the mean (average) of a list of numbers.\\\"},{\\\"function_name\\\":\\\"calculate_median\\\",\\\"function_description\\\":\\\"Calculates and returns the median of a list of numbers.\\\"},{\\\"function_name\\\":\\\"calculate_variance\\\",\\\"function_description\\\":\\\"Calculates and returns the variance of a list of numbers based on the given mean.\\\"},{\\\"function_name\\\":\\\"calculate_standard_deviation\\\",\\\"function_description\\\":\\\"Calculates and returns the standard deviation from the variance.\\\"},{\\\"function_name\\\":\\\"sort_numbers\\\",\\\"function_description\\\":\\\"Sorts the list of numbers in ascending or descending order based on the 'descending' parameter.\\\"},{\\\"function_name\\\":\\\"generate_statistics\\\",\\\"function_description\\\":\\\"Generates and returns a dictionary containing the mean, median, variance, and standard deviation of a list of numbers.\\\"},{\\\"function_name\\\":\\\"print_statistics\\\",\\\"function_description\\\":\\\"Prints the statistical metrics (mean, median, variance, standard deviation) in a formatted manner.\\\"},{\\\"function_name\\\":\\\"main\\\",\\\"function_description\\\":\\\"Main function that ties together the generation of random numbers, sorting, calculating statistics, and printing the results.\\\"}]}\"\n            }\n        ]\n        },\n        {\n        \"role\": \"user\",\n        \"content\": [\n            {\n            \"type\": \"text\",\n            \"text\": python_file_string\n            }\n        ]\n        }\n    ],\n    temperature=1,\n    max_tokens=2048,\n    top_p=1,\n    frequency_penalty=0,\n    presence_penalty=0,\n    response_format={\n        \"type\": \"json_schema\",\n        \"json_schema\": {\n        \"name\": \"function_descriptions\",\n        \"schema\": {\n            \"type\": \"object\",\n            \"required\": [\n            \"function_information\"\n            ],\n            \"properties\": {\n            \"function_information\": {\n                \"type\": \"array\",\n                \"items\": {\n                \"type\": \"object\",\n                \"required\": [\n                    \"function_name\",\n                    \"function_description\"\n                ],\n                \"properties\": {\n                    \"function_name\": {\n                    \"type\": \"string\"\n                    },\n                    \"function_description\": {\n                    \"type\": \"string\"\n                    }\n                },\n                \"additionalProperties\": False\n                }\n            }\n            },\n            \"additionalProperties\": False\n        },\n        \"strict\": True\n        }\n    }\n    )\n    text = response.choices[0].message.content\n    return text\n\ndef summarize_functions_in_directory(directory_path, output_json_path):\n    function_summaries = {}\n\n    # Walk through all files and subdirectories within the directory\n    for root, _, files in os.walk(directory_path):\n        for filename in files:\n            if filename.endswith('.py'):\n                # Get the full file path\n                file_path = os.path.join(root, filename)\n                \n                # Compute the relative path from the root directory\n                relative_path = os.path.relpath(file_path, directory_path)\n                \n                with open(file_path, 'r') as file:\n                    python_file_string = file.read()\n                \n                # Get the function summaries using the summarize_functions function\n                try:\n                    summary_json = summarize_functions(python_file_string)\n                    # Parse the JSON string into a Python dictionary\n                    summary = json.loads(summary_json)\n                except Exception as e:\n                    print(f\"Error summarizing {relative_path}: {e}\")\n                    summary = {\"error\": str(e)}\n                \n                # Add the summary to the dictionary with the relative path as the key\n                function_summaries[relative_path] = summary\n\n    # Write the collected summaries to the output JSON file\n    with open(output_json_path, 'w') as json_file:\n        json.dump(function_summaries, json_file, indent=4)\n\n    print(f\"Function summaries have been written to {output_json_path}\")\n\n\n\n# Example usage\nif __name__ == \"__main__\":\n    directory_path = '/Users/typham-swann/Desktop/research_code_app/python_logic_tester/sample_directory'  # Replace with your directory path\n    output_json_path = '/Users/typham-swann/Desktop/research_code_app/python_logic_tester/function_descriptions.json'    # Output JSON file path\n\n    summarize_functions_in_directory(directory_path, output_json_path)\n",
        "function_information": [
            {
                "function_name": "summarize_functions",
                "function_description": "Takes a string of Python code and uses the OpenAI API to summarize all functions, returning a JSON-encoded string containing function names and descriptions."
            },
            {
                "function_name": "summarize_functions_in_directory",
                "function_description": "Walks through the specified directory to find Python files, reads each file's content, summarizes the functions using summarize_functions, and outputs the summaries as a JSON file at the specified output path."
            },
            {
                "function_name": "main",
                "function_description": "Example usage of summarize_functions_in_directory, specifying a directory to summarize and an output path for the summary JSON file."
            }
        ],
        "file_summary": "The `generate_summaries.py` script is a Python utility designed for summarizing functions within Python scripts. It leverages the OpenAI API to analyze and return summaries of Python code functions. The main components of the script are as follows:\n\n1. **summarize_functions**: This function takes a string representation of Python code and uses the OpenAI API to summarize all functions within the provided code. It returns a JSON-encoded string containing the function names and their respective descriptions.\n\n2. **summarize_functions_in_directory**: This function navigates through a specified directory and identifies Python files. For each file, it reads the file content and uses the `summarize_functions` to generate function summaries. These summaries are then compiled into a dictionary with relative file paths as keys, and the result is saved as a JSON file at a specified output path.\n\n3. **main**: Demonstrates the usage of `summarize_functions_in_directory`. It specifies a directory path containing Python scripts and an output path for the JSON file where function summaries will be written.\n\nThe script relies on the OpenAI client, configured with an API key, to connect and retrieve function summaries. It interacts with the file system to read Python scripts, processes them, and writes summarized descriptions into a JSON file, serving as documentation or analysis tool for the codebase within the specified directory."
    },
    "sample_directory/scripts/model_training.py": {
        "code": "from sklearn.linear_model import LinearRegression\n\ndef train_model(X, y):\n    model = LinearRegression()\n    model.fit(X, y)\n    return model\n\ndef predict(model, X_new):\n    predictions = model.predict(X_new)\n    return predictions\n\ndef evaluate_model(model, X_test, y_test):\n    score = model.score(X_test, y_test)\n    return score\n",
        "function_information": [
            {
                "function_name": "train_model",
                "function_description": "Trains a Linear Regression model using the provided features (X) and target (y) data, and returns the trained model."
            },
            {
                "function_name": "predict",
                "function_description": "Generates predictions using a trained Linear Regression model and new input feature data (X_new)."
            },
            {
                "function_name": "evaluate_model",
                "function_description": "Evaluates the performance of a trained Linear Regression model using test data (X_test and y_test), returning the model's score (coefficient of determination R^2)."
            }
        ],
        "file_summary": "The `model_training.py` file is a script focused on operations related to training and evaluating a linear regression model. It uses the `LinearRegression` class from the `scikit-learn` library to perform its tasks. The script defines three primary functions:\n\n1. `train_model(X, y)`: This function takes input features `X` and target values `y`, trains a linear regression model, and returns the trained model.\n\n2. `predict(model, X_new)`: This function uses the trained linear regression model to generate predictions for new input data `X_new`. It returns the array of predictions.\n\n3. `evaluate_model(model, X_test, y_test)`: This function evaluates the performance of the trained model on test data, `X_test` and `y_test`, returning the model's score, which is the coefficient of determination R^2.\n\nThe script depends on external CSV data input and likely requires preprocessing of data to provide it with the `X` and `y` inputs, which might be handled by another script in the project such as `data_processing.py`. Additionally, outputs of the predictions or evaluations might be used by other scripts like those for data visualization or reporting."
    },
    "sample_directory/scripts/visualization.py": {
        "code": "import matplotlib.pyplot as plt\n\ndef plot_data(data):\n    plt.plot(data['date'], data['value'])\n    plt.show()\n\ndef save_plot(data, filepath):\n    plt.plot(data['date'], data['value'])\n    plt.savefig(filepath)\n",
        "function_information": [
            {
                "function_name": "plot_data",
                "function_description": "Plots the data using Matplotlib, displaying a line graph of 'value' over 'date'."
            },
            {
                "function_name": "save_plot",
                "function_description": "Plots the data using Matplotlib and saves the line graph as an image to the specified file path."
            }
        ],
        "file_summary": "The `visualization.py` script contains functions for visualizing data using Matplotlib. It includes two functions:\n\n1. `plot_data(data)`: Takes a dictionary with keys 'date' and 'value', plotting these as a line graph and displaying it. This function expects that the input data is already prepared in a format suitable for plotting.\n\n2. `save_plot(data, filepath)`: Similar to `plot_data`, but instead of displaying the plot, it saves the plot as an image to the specified file path.\n\nThe script assumes the input data has 'date' and 'value' keys, corresponding to the x-axis and y-axis, respectively. This module is designed to be a part of a data analysis pipeline where data plotting and saving functionality is required. No external files or functions from outside this file are invoked directly within this script."
    },
    "sample_directory/scripts/data_processing.py": {
        "code": "import pandas as pd\n\ndef load_data(filepath):\n    data = pd.read_csv(filepath)\n    return data\n\ndef clean_data(data):\n    data = data.dropna()\n    data = data[data['value'] >= 0]\n    return data\n\ndef save_clean_data(data, filepath):\n    data.to_csv(filepath, index=False)\n",
        "function_information": [
            {
                "function_name": "load_data",
                "function_description": "Loads data from a CSV file given by 'filepath' into a pandas DataFrame."
            },
            {
                "function_name": "clean_data",
                "function_description": "Cleans the DataFrame by removing rows with NaN values and ensuring the 'value' column has non-negative entries."
            },
            {
                "function_name": "save_clean_data",
                "function_description": "Saves the cleaned DataFrame to a CSV file at the specified 'filepath' without writing the index."
            }
        ],
        "file_summary": "The `data_processing.py` script is dedicated to managing and preparing datasets for analysis. It uses the pandas library to handle data in CSV format. The script includes three primary functions:\n\n1. `load_data(filepath)`: This function reads a CSV file specified by the `filepath` into a pandas DataFrame, allowing for further data manipulation and analysis.\n\n2. `clean_data(data)`: This function cleans the DataFrame by removing any rows with missing values (NaN) and filtering out rows where the 'value' column is negative, ensuring only valid and relevant data is retained.\n\n3. `save_clean_data(data, filepath)`: This function saves the cleaned DataFrame back to a CSV file at the specified `filepath` without including the index, finalizing the cleaning process and preparing the data for subsequent analysis or modeling steps.\n\nThese functions are essential prerequisites for tasks such as model training and visualization, facilitating a clean and structured dataset for these subsequent processes."
    }
}